<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
    <title>ðŸ˜· jazhawang's blog</title>
    <!-- styles -->
    <link rel="stylesheet" type="text/css" href="css/normalize.css">
    <link rel="stylesheet" type="text/css" href="css/default.css">
    <style>
        body { 
            margin: 0;
            background-color: #FFFAF4; 
        }
    </style>
</head>

<body>

<canvas id="c"></canvas>

<script type="module">

import * as THREE from 'https://cdn.skypack.dev/pin/three@v0.128.0-qS9Si1DbCh3Y4U3kxP8d/mode=imports,min/optimized/three.js';
import {OrbitControls} from 'https://cdn.skypack.dev/pin/three@v0.128.0-qS9Si1DbCh3Y4U3kxP8d/mode=imports,min/unoptimized/examples/jsm/controls/OrbitControls.js';
import {GLTFLoader} from 'https://cdn.skypack.dev/pin/three@v0.128.0-qS9Si1DbCh3Y4U3kxP8d/mode=imports,min/unoptimized/examples/jsm/loaders/GLTFLoader.js';

function main() {

  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});

  const fov = 45;
  const aspect = 2;  // the canvas default
  const near = 0.1;
  const far = 100;

  const camera = new THREE.OrthographicCamera(-aspect, aspect, aspect/2, -aspect/2, near, far);
  camera.position.set(2, 8, 5);
  camera.zoom = 0.15;

  const controls = new OrbitControls(camera, canvas);
  controls.target.set(0, 5, 0);
  controls.update();

  const scene = new THREE.Scene();
  scene.background = new THREE.Color('#FFFAF4');

  let mouse = new THREE.Vector2();


  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

  /*{
    const sphereRadius = 0.1;
    const sphereWidthDivisions = 32;
    const sphereHeightDivisions = 16;
    const sphereGeo = new THREE.SphereGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
    const sphereMat = new THREE.MeshPhongMaterial({color: '#CA8'});
    const mesh = new THREE.Mesh(sphereGeo, sphereMat);
    
    mesh.position.set(-3, 2, 0);
    scene.add(mesh);
  }*/

  function dumpObject(obj, lines = [], isLast = true, prefix = '') {
      const localPrefix = isLast ? 'â””â”€' : 'â”œâ”€';
      lines.push(`${prefix}${prefix ? localPrefix : ''}${obj.name || '*no-name*'} [${obj.type}]`);
      const newPrefix = prefix + (isLast ? '  ' : 'â”‚ ');
      const lastNdx = obj.children.length - 1;
      obj.children.forEach((child, ndx) => {
        const isLast = ndx === lastNdx;
        dumpObject(child, lines, isLast, newPrefix);
      });
      return lines;
    }

  let coffeePlane, boat, boatInfo;
  const loader = new GLTFLoader();
  loader.load(
    './assets/coffeecup.glb',
    function (gltf) {
      const root = gltf.scene;
      scene.add(root);
      console.log(dumpObject(root).join('\n'));
      coffeePlane = root.getObjectByName('coffee');
      boat = root.getObjectByName('boat');
      boatInfo = {
        origPos: {...boat.position},
        velocity: new THREE.Vector2(0.0, 0.0),
        offset: new THREE.Vector2(0.0, 0.0),
        tRot: boat.rotation.y,
      };
    }
  );

  {
    const color = 0xB97A20;
    const intensity = 0.15;

    let light, i, x,y,z;
    light = new THREE.DirectionalLight(color, intensity);
    light.position.set(1,1,2);

    light.target.position.set(0, 0, 0);
      scene.add(light);
      scene.add(light.target);
  }

  {
    const skyColor = 0xF1F1FF;
    const groudColor = 0xA98A40;
    const intensity = 1;

    const light = new THREE.HemisphereLight(skyColor, groudColor, intensity);
    scene.add(light);
  }


  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function onMouseMove( event ) {
    mouse.x = event.clientX - window.innerWidth/2.0;
    mouse.y = event.clientY - window.innerHeight/2.0;
  }


  function render(time) {
    time *= 0.001;
    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    if (coffeePlane) {
      //coffeePlane.rotation.y = time;
    }
    if (boat) {

      boatInfo.velocity.add(mouse.clampScalar(-0.001, 0.001));
      boatInfo.velocity.clampLength(0, 0.1);

      let dx = boatInfo.velocity.x*time;
      let dy = boatInfo.velocity.y*time;
      let d = new THREE.Vector2(dx, dy);

      d.clampLength(0, 0.0015);
      boatInfo.offset.add(d);

      boatInfo.offset.clampLength(0, 1.5);
      boat.position.x = boatInfo.origPos.x + boatInfo.offset.x;
      boat.position.z = boatInfo.origPos.z + boatInfo.offset.y;

      boat.position.y = boatInfo.origPos.y + 0.01*Math.sin(3*time);

      // calculate the current boat direction unit vector
      let gamma = boatInfo.tRot;
      let by = Math.cos(gamma); // weird
      let bx = Math.sin(gamma);
      let boatDirVec = new THREE.Vector2(bx,by);
      // cosine rule
      let theta = Math.acos(boatDirVec.dot(boatInfo.velocity) / (boatInfo.velocity.length()*boatDirVec.length()));

      if (theta > 0.015) { // remove some jitter
        if (bx*boatInfo.velocity.y - by*boatInfo.velocity.x < 0) {
          theta = 2*Math.PI - theta;
        }
        boatInfo.tRot +=  0.01 * (theta-Math.PI/2.0);
        boat.rotation.y = boatInfo.tRot - Math.PI/2.0;
      }

      
    }
    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
  window.addEventListener( 'mousemove', onMouseMove, false );
}

main();
</script>

</body>
</html> 