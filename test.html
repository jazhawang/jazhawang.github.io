<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
    <title>ðŸ˜· jazhawang's blog</title>
    <!-- styles -->
    <link rel="stylesheet" type="text/css" href="css/normalize.css">
    <link rel="stylesheet" type="text/css" href="css/default.css">
    <style>
        body { 
            margin: 0;
            background-color: #FFFAF4; 
        }
    </style>

  
</head>

<body>

<canvas id="c"></canvas>

<script type="module">

import * as THREE from 'https://cdn.skypack.dev/pin/three@v0.128.0-qS9Si1DbCh3Y4U3kxP8d/mode=imports,min/optimized/three.js';
import {GLTFLoader} from 'https://cdn.skypack.dev/pin/three@v0.128.0-qS9Si1DbCh3Y4U3kxP8d/mode=imports,min/unoptimized/examples/jsm/loaders/GLTFLoader.js';
//import {FontLoader} from 'https://cdn.skypack.dev/pin/three@v0.128.0-qS9Si1DbCh3Y4U3kxP8d/mode=imports,min/unoptimized/examples/jsm/loaders/FontLoader.js';

function main() {

  const scene = new THREE.Scene();

  let coffeePlane, boat, boatInfo;
  const loader = new GLTFLoader();
  loader.load(
    './assets/coffeecup.glb',
    function (gltf) {
      const root = gltf.scene;
      scene.add(root);
      coffeePlane = root.getObjectByName('coffee');
      boat = root.getObjectByName('boat');
      root.position.y -= 1.0;
      boatInfo = {
        origPos: {...boat.position},
        velocity: new THREE.Vector2(0.0, 0.0),
        offset: new THREE.Vector2(0.0, 0.0),
        tRot: boat.rotation.y,
      };
    }
  );

  const fontLoader = new THREE.FontLoader();
  const font = fontLoader.load(
    './assets/fonts/serat.json',
    function (font) {
      const textGeometry = new THREE.TextGeometry(
        'Welcome\nWelcome',
        {
          font: font,
          size: 3,
          height: 0,
          curveSegments: 8,
        }
      );
      var textMaterial = new THREE.MeshPhongMaterial( 
        { color: 0xC97A20, specular: 0xffffff }
      );
      var mesh = new THREE.Mesh( textGeometry, textMaterial );
      mesh.position.set(-9,9,0);

      scene.add( mesh );
      console.log("added");

  });


  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  const fov = 45;
  const aspect = 2;
  const near = 0.1;
  const far = 100;

  // why do we need to divide?
  const camera = new THREE.OrthographicCamera(-aspect, aspect, aspect/2, -aspect/2, near, far);
  camera.position.set(2, 8, 6);
  camera.lookAt(0,5,0);
  camera.zoom = 0.12;

  scene.background = new THREE.Color('#FFFAF4');
  let mouse = new THREE.Vector2();
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  {
    const color = 0xB97A20;
    const intensity = 0.15;

    let light, i, x,y,z;
    light = new THREE.DirectionalLight(color, intensity);
    light.position.set(1,1,2);

    light.target.position.set(0, 0, 0);
      scene.add(light);
      scene.add(light.target);
  }

  {
    const skyColor = 0xF1F1FF;
    const groudColor = 0xA98A40;
    const intensity = 1;

    const light = new THREE.HemisphereLight(skyColor, groudColor, intensity);
    scene.add(light);
  }


  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function onMouseMove( event ) {
    mouse.x = event.clientX - window.innerWidth/2.0;
    mouse.y = event.clientY - window.innerHeight/2.0;
  }


  function render(time) {
    time *= 0.001;
    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    if (coffeePlane) {
      //coffeePlane.rotation.y = time;
    }
    if (boat) {

      boatInfo.velocity.add(mouse.clampScalar(-0.001, 0.001));
      boatInfo.velocity.clampLength(0, 0.1);

      let dx = boatInfo.velocity.x*time;
      let dy = boatInfo.velocity.y*time;
      let d = new THREE.Vector2(dx, dy);

      d.clampLength(0, 0.0015);
      boatInfo.offset.add(d);

      boatInfo.offset.clampLength(0, 1.5);
      boat.position.x = boatInfo.origPos.x + boatInfo.offset.x;
      boat.position.z = boatInfo.origPos.z + boatInfo.offset.y;

      boat.position.y = boatInfo.origPos.y + 0.01*Math.sin(3*time);

      // calculate the current boat direction unit vector
      // hacky - fix this
      let gamma = boatInfo.tRot;
      let by = Math.cos(gamma); // why
      let bx = Math.sin(gamma);
      let boatDirVec = new THREE.Vector2(bx,by);
      // cosine rule
      let theta = Math.acos(boatDirVec.dot(boatInfo.velocity) / (boatInfo.velocity.length()*boatDirVec.length()));

      if (theta > 0.015) { // remove some jitter
        if (bx*boatInfo.velocity.y - by*boatInfo.velocity.x < 0) {
          theta = 2*Math.PI - theta;
        }
        boatInfo.tRot +=  0.01 * (theta-Math.PI/2.0);
        boat.rotation.y = boatInfo.tRot - Math.PI/2.0;
      }

      
    }
    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
  window.addEventListener( 'mousemove', onMouseMove, false );
}

main();
</script>

</body>
</html> 