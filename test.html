<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
    <title>ðŸ˜· jazhawang's blog</title>
    <!-- styles -->
    <link rel="stylesheet" type="text/css" href="css/normalize.css">
    <link rel="stylesheet" type="text/css" href="css/default.css">
    <style>
        body { 
            margin: 0;
            background-color: #FFFAF4; 
        }
    </style>
</head>

<body>

<canvas id="c"></canvas>

<script type="module">

import * as THREE from 'https://cdn.skypack.dev/pin/three@v0.128.0-qS9Si1DbCh3Y4U3kxP8d/mode=imports,min/optimized/three.js';
import {OrbitControls} from 'https://cdn.skypack.dev/pin/three@v0.128.0-qS9Si1DbCh3Y4U3kxP8d/mode=imports,min/unoptimized/examples/jsm/controls/OrbitControls.js';
import {GLTFLoader} from 'https://cdn.skypack.dev/pin/three@v0.128.0-qS9Si1DbCh3Y4U3kxP8d/mode=imports,min/unoptimized/examples/jsm/loaders/GLTFLoader.js';

function main() {

  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});

  const fov = 45;
  const aspect = 2;  // the canvas default
  const near = 0.1;
  const far = 100;

  const camera = new THREE.OrthographicCamera(-aspect, aspect, aspect/2, -aspect/2, near, far);
  camera.position.set(2, 8, 5);
  camera.zoom = 0.15;

  const controls = new OrbitControls(camera, canvas);
  controls.target.set(0, 5, 0);
  controls.update();

  const scene = new THREE.Scene();
  scene.background = new THREE.Color('#FFFAF4');

  let mouse = new THREE.Vector2();


  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

  /*{
    const sphereRadius = 0.1;
    const sphereWidthDivisions = 32;
    const sphereHeightDivisions = 16;
    const sphereGeo = new THREE.SphereGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
    const sphereMat = new THREE.MeshPhongMaterial({color: '#CA8'});
    const mesh = new THREE.Mesh(sphereGeo, sphereMat);
    
    mesh.position.set(-3, 2, 0);
    scene.add(mesh);
  }*/

  function dumpObject(obj, lines = [], isLast = true, prefix = '') {
      const localPrefix = isLast ? 'â””â”€' : 'â”œâ”€';
      lines.push(`${prefix}${prefix ? localPrefix : ''}${obj.name || '*no-name*'} [${obj.type}]`);
      const newPrefix = prefix + (isLast ? '  ' : 'â”‚ ');
      const lastNdx = obj.children.length - 1;
      obj.children.forEach((child, ndx) => {
        const isLast = ndx === lastNdx;
        dumpObject(child, lines, isLast, newPrefix);
      });
      return lines;
    }

  let coffeePlane, boat, boatOrigPos;
  const loader = new GLTFLoader();
  loader.load(
    './assets/coffeecup.glb',
    function (gltf) {
      const root = gltf.scene;
      scene.add(root);
      console.log(dumpObject(root).join('\n'));
      coffeePlane = root.getObjectByName('coffee');
      boat = root.getObjectByName('boat');
      boatOrigPos = {...boat.position};
    }
  );

  {
    const color = 0xB97A20;
    const intensity = 0.15;

    let light, i, x,y,z;
    light = new THREE.DirectionalLight(color, intensity);
    light.position.set(1,1,2);

    light.target.position.set(0, 0, 0);
      scene.add(light);
      scene.add(light.target);
  }

  {
    const skyColor = 0xF1F1FF;
    const groudColor = 0xA98A40;
    const intensity = 1;

    const light = new THREE.HemisphereLight(skyColor, groudColor, intensity);
    scene.add(light);
  }


  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function onMouseMove( event ) {
    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
  }


  function render(time) {
    time *= 0.001;
    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    if (coffeePlane) {
      //coffeePlane.rotation.y = time;
    }
    if (boat) {

      boat.position.y = boatOrigPos.y + 0.01*Math.sin(3*time);
      let dx = mouse.x*time;
      let dz = mouse.y*time;

      boat.position.x = boatOrigPos.x + 0.01*dx;
      boat.position.z = boatOrigPos.z + 0.01*dz;


    }
    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
  window.addEventListener( 'mousemove', onMouseMove, false );
}

main();
</script>

</body>
</html> 